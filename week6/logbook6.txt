NiceOrUgly - 
Initial Thoughts:
This question i can tell is another dp/dfs quesiton where i go through the string first checking if it has 3 vowels in a row or 5 consanants
in a row, then if its a ? i call itself checking both cases where its a vowel or a consanant. Since the constraints are only 50 
a DFS or dp appraoch would work, ill try need to make a dfs contains the current index, number of current consecutive vowels 
and consanant as well as if a string found is nice or ugly. At the end of the string we just need to check if the boolean value of nice and ugly 
are true or not, i fboth true return 42.

Reflection:
This question took some time becasue i realised that brute force dfs wasnt going to work due tp the large constraints assuming 50 
"?". i didnt take that into account, so i had to add memoisation to optimise the code ensurign it doesnt recalculate calculations
that have already been done. I should of initially used a dp approach because although its quite similar its easier to understand
whats going on. The only hard part about this question was implementing the memoisation becasue it had to contain multiple variabels.


BlackAndWhiteSolitaire - 
Initial Thoughts:
This question looks quite easy proabbly becasue i have a cheese method of solving it, becasue there are low constraints and only
two options. i figure out the size and build out a repeating pattern of that size one that starts with white and one with black,
then i simply compare it with the origina string keeping count of how many times dies it differ and then just return the minimum 
difference.

Reflection:
As i expected the question was quite easy to complete however after checking with AI i definetly coulve made my code a lot more consise,
i was creating strings B and W however if n were very large in this case, it would take a lot of exrta memory. Instead i shoulve 
just created two scenarios checking if it was an W or B rather than creating unnessary strings that waste memory. I always try
to opt for the most optimal route so ill keep that in the back of my mind as i progress further.


SimpleDuplicateRemover - 
Initial Thoughts:
This question looks quite simple, my initial idea is to create a vector then first loop through starting from the right and if 
it hasn't been found, simply add it to the vector. If it is in the vector then just skip it, and continue the iteration. Then 
just return the vector but reversed. Another idea i just got is to not create another vector and just work on the original vector
rather than creaging a new one like i did in the previous question. im going to use an set to keep track of values found.

Reflection:
I realised it wasnt possible wihtout creating a new vector becasue it returns one and doesnt give the address just the copy so 
i had to create a vector and a set, if the number wasnt found in the set add it to the set and vector, otherwise just move on. 
At the end you simply reverse it so it keeps the rightmost logic. This question was quite easy and i feel like i get the hang of
most of these two star questions.


Important task - 
Initial Thoughts:
This question is from week 4 but i never had the chance to look at all the question till now, To approach this problem my first 
idea is to sort both complexity and computers and simply compared the max indexes. Simply loop around the computer until there are no
more computers. I dont see why this simple solution wont work.

Reflection:
This question took longer than it shoulve becasue i forgot to sort it in reversed order making the outputs wrong every time and
couldn't figur eout why. Next time i should think carefully about each step rather than waste time submitting code casue of one
small error. Other than that the uestion was quite easy to solve compared toall the dyanmic quesitons.


OVERALL REFLECTION:
This week question were quite easy but thats becasue i chose to do them rather than try the really hard ones, i think for me it 
imperative that i do something in my skill level and just slowly progress becasue whenever i am faced with a hard quiestion 
that i can't figure it out, i just quit in general becasue i get too fustrated and coding isn't enjoyabnle anymore. A new method 
ive found for myslef is to simply just do the questions i know im able ot solve and get really good at them for the foundation because
i can definetly tell ive imporved a lot since week1. Right now im sitll learning dp but once i get the hang of it ill be 
unstoppable.
