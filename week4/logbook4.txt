MagicSpell - 
Initial Thoughts:
This question looks quite easy, my idea is to use two pointers starting from both ends and when they both encounter an A or a Z
i use the swap function so this ensures it doesnt just change from A to Z but also changes in the right position wihtout altering 
the rest of the string. Now im thinking about it im not sure how to move once one of them hits an A or Z and then move the other
pointer. im just going to try Initially using a while loop and then incrementing the l and r.

Reflection:
Yeah as i thought it was quite a simple solution using two pointers, simply checking if the letter matches with an A or Z and then
if it passes through both if statements, just swap them. Very simple and clean solution, im sure there is a better way like amybe
storing the letters into a vector but my solution was the easiest for me to implement. Great question to start off.


RugSizes - 
Initial Thoughts:
This question stumpped me for a bit because i have trouble understading what the questions asking, but i get it now, i jsut have to 
find the amount of rugs that fit three criteria: width and length have to equal the desired area, width and length cannot be 
different and even, meaning square even rugs are fine, and not duplicates so 6x9 != 9x6. To fit the first criteria it should be Very
easy, simply if (width x length == area), second one can be dones with if staments checking if it is even and not equal. And to 
fit the final one i can simple just loop up until the square root of the area as it would stop checking after due to duplication.

Reflection:
It was a very simple and elegant solution with very few lines of code, i followed my inital thoughts exactly and didnt run into
many problems. If i want to improve i should attempt harder questions that invovle dynamic programming.


UnsealTheSafe -
Initial Thoughts:
This question involves dynamic programming but im not very confident in how to solve it, i think ill need to use AI or my friedns
help to understad how to implemnet it. I know you have to create an adjacency vector to store all possible options but im not 
sure where to go from then. Ill try my best.

Reflection:
I had to get help from AI to help explain and solve this dp becasue im very new to this and i dont understand how it works. first
you had to build a adjacency table, then create a dp table with N+1 rows and 10 columns which are intialised to 0. First you have to 
build a base case where if N would equal 1. Then you have to do nested for loops so for each leangth and each digit, you have to 
compute the number of sequences ending at d. To end at d, the prevoius digit must be one of adj[d], so we loop and add up all ways
from dp[len-1][prev]. After we filled the table we just count the sequences ending with each digit.


MonstersValley2 -
Initial Thoughts - 
This question looks very interesting, i can tell u should be using dynamic progrmaming or backtracking becasue the constraints 
are only up to 20. I want to try and implement dp but im still very new, by backtrakcing i can brute force my way to the solution
and its a lot easier for me to visualise. I going to use a helper function to first establish a base case that keeps track of the 
minimum gold spent, and its inputs would be the index, current dread and gold. I can then simply use recursion to go through
every possibility.

Reflection:




